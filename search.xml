<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>50 years, 50 colors</title>
      <link href="2019/04/07/50-years-50-colors/"/>
      <url>2019/04/07/50-years-50-colors/</url>
      
        <content type="html"><![CDATA[<p>这个题是最小点覆盖</p><p>根据定理也就是求二分图的最大匹配（证明没看懂）</p><p>就是我们把行拿出来作为左部分，列拿出来作为右部分，然后两者相连的边就代表了原图中的点</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<map>#include<string.h>using namespace std;int un,uv;map<int,int>m;const int maxn = 100+10;int g[maxn][maxn];int linker[maxn];int used[maxn];int n,k;int res[100];bool dfs(int u,int t){    for(int v = 0;v<uv;++v){        if(g[u][v]==t&&!used[v]){            used[v] = true;            if(linker[v]==-1||dfs(linker[v],t)){            linker[v] = u;            return true;}        }    }    return false;}int hungry(int t){    int res = 0;    memset(linker,-1,sizeof(linker));    for(int u =0;u<un;++u){        memset(used,false,sizeof(used));        if(dfs(u,t))res++;    }    return res;}int main(){    while(~scanf("%d%d",&n,&k)&&n+k!=0){            m.clear();            un = n,uv= n;        for(int i = 0;i<n;++i){            for(int j =0;j<n;++j){                scanf("%d",&g[i][j]);                m[g[i][j]]=1;            }        }        int h = 0;        map<int,int>::iterator it;        for(it = m.begin();it!=m.end();++it){            if(hungry(it->first)>k){                res[h++]=it->first;            }        }        if(h==0)            cout<<-1<<endl;        else{                for(int i =0;i<h;++i){                    if(i)                        cout<<" "<<res[i];                    else                        cout<<res[i];                }                cout<<endl;            }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找的变异写法</title>
      <link href="2019/04/07/er-fen-cha-zhao-de-bian-yi-xie-fa/"/>
      <url>2019/04/07/er-fen-cha-zhao-de-bian-yi-xie-fa/</url>
      
        <content type="html"><![CDATA[<p>最近接触的二分查找变的多了起来</p><p>先推荐一篇很不错的博客叭</p><p><a href="https://blog.csdn.net/zxzxzx0119/article/details/82670761">https://blog.csdn.net/zxzxzx0119/article/details/82670761</a></p><p>首先二分查找普通的写法就是</p><pre class=" language-c++"><code class="language-c++">int bina(int *a,int key){    int l = 1;    int r = n;    int coun = 0;    while(l<=r){        //coun++; printf("%d\n",coun);        int mid = (l+r)>>1;        if(a[mid]==key){            return mid;        }        if(a[mid]>=key){            r = mid-1;        }        else{            l = mid+1;        }    }    return -1;}</code></pre><p>这个地方l一定是从开始的下标，r一定是结束的下标</p><p>这种写法是比较方便的</p><p>但是这种方法的前提是数组递增且不存在重复的元素</p><p>所以当存在重复的元素时我们便面临如何选取的问题</p><p>这里我简单介绍三种方法，并且进行一个相应的总结相关的写法（也是根据链接博客里面的详细讲解总结的）</p><p>首先是找到相同元素最左边的元素</p><pre class=" language-c++"><code class="language-c++">int bina(int *a,int key){    int l = 1;    int r = n;    int coun = 0;    while(l<=r){        //coun++; printf("%d\n",coun);        int mid = (l+r)>>1;       /* if(a[mid]==key){            return mid;        }*/        if(a[mid]>=key){            r = mid-1;        }        else{            l = mid+1;        }    }    if(l<=n&&a[l]==key){        return l;    }    return -1;}</code></pre><p>可以看到这里我们把a[mid]==key的判断条件注释掉了</p><p>while里面判断的关键在于r=mid-1的&gt;=号 意思是就算找到a[mid]==key区间也要往右缩进直到找到第一个大于等于key的元素</p><p>如果这个元素的下标合理（l&lt;=n）且这个元素==key那么就找到了key返回下标 否则返回-1</p><p>那么我们可以根据此推出第二种情况 找到第一个&gt;=key的元素</p><p>其实上一个我们找到的就是第一个&gt;=key的元素 下面的条件只不过是加了一个特判</p><p>所以代码为</p><pre class=" language-c++"><code class="language-c++">int bina(int *a,int key){    int l = 1;    int r = n;    int coun = 0;    while(l<=r){        //coun++; printf("%d\n",coun);        int mid = (l+r)>>1;       /* if(a[mid]==key){            return mid;        }*/        if(a[mid]>=key){            r = mid-1;        }        else{            l = mid+1;        }    }    return l;}</code></pre><p>那么第三种情况是找第一个&gt;key的元素，所以这里我们可以直接把上一个while里面的判断条件改成&gt;key就ok辽</p><pre class=" language-c++"><code class="language-c++">int bina(int *a,int key){    int l = 1;    int r = n;    int coun = 0;    while(l<=r){        //coun++; printf("%d\n",coun);        int mid = (l+r)>>1;       /* if(a[mid]==key){            return mid;        }*/        if(a[mid]>key){            r = mid-1;        }        else{            l = mid+1;        }    }    return l;}</code></pre><p>那么如果找最后一个或者最右边的话把l和r调换一下就ok了！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超棒的数位dp入门（转）</title>
      <link href="2019/01/21/chao-bang-de-shu-wei-dp-ru-men-zhuan/"/>
      <url>2019/01/21/chao-bang-de-shu-wei-dp-ru-men-zhuan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wust_zzwh/article/details/52100392">https://blog.csdn.net/wust_zzwh/article/details/52100392</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj1125 spfa最短路</title>
      <link href="2018/09/19/poj1125-spfa-zui-duan-lu/"/>
      <url>2018/09/19/poj1125-spfa-zui-duan-lu/</url>
      
        <content type="html"><![CDATA[<pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<queue>#include<string.h>using namespace std;int inf=0x3f3f3f;int a[105];int n;int mp[105][105];int dis[105];int vis[105];int sum=0x3f3f3f,pot;void init(){    sum=0x3f3f3f;    memset(mp,0,sizeof(mp));    for(int i=1;i<=n;++i)    {        int m;        scanf("%d",&m);        for(int j=1;j<=m;++j)        {            int x,y;            scanf("%d%d",&x,&y);            mp[i][x]=y;        }    }    for(int i=1;i<=100;++i)    {        for(int j=1;j<=100;++j)        {            if(mp[i][j]==0&&i!=j)                mp[i][j]=inf;        }    }}void spfa(int start){    queue<int>q;    for(int i=1;i<=n;++i)    {        dis[i]=inf;        vis[i]=false;    }    dis[start]=0;    int now;    vis[start]=true;    q.push(start);    while(!q.empty())    {        now=q.front();        q.pop();        vis[now]=false;        for(int i=1;i<=n;++i)        {            if(dis[i]>mp[now][i]+dis[now])            {                dis[i]=mp[now][i]+dis[now];                if(vis[i]==0)                {                    q.push(i);                    vis[i]=true;                }            }        }    }    int sum1=0;    for(int i=1;i<=n;++i)    {        if(dis[i]==inf)        {            return;        }        if(dis[i]>sum1)            sum1=dis[i];    }    if(sum1<sum)    {        sum=sum1;        pot=start;    }}int main(void){    while(scanf("%d",&n)&&n)    {        init();        for(int i=1;i<=n;++i)            spfa(i);        if(sum==0)            printf("disjoint\n");        else        {            printf("%d %d\n",pot,sum);        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> spfa </tag>
            
            <tag> poj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu2467 拓扑排序（逆向建图）</title>
      <link href="2018/08/09/hdu2467-tuo-bu-pai-xu-ni-xiang-jian-tu/"/>
      <url>2018/08/09/hdu2467-tuo-bu-pai-xu-ni-xiang-jian-tu/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h3><p>Time Limit: 1000 ms / Memory Limit: 32768 kb</p><p>Description</p><p>Dandelion’s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.<br>The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a’s reward should more than b’s.Dandelion’s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work’s reward will be at least 888 , because it’s a lucky number.</p><p>Input</p><p>One line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)<br>then m lines ,each line contains two integers a and b ,stands for a’s reward should be more than b’s.</p><p>Output</p><p>For every case ,print the least money dandelion ‘s uncle needs to distribute .If it’s impossible to fulfill all the works’ demands ,print -1.</p><p>Sample Input</p><pre><code></code></pre><p>2 1 1 2 2 2 1 2 2 1</p><p>Sample Output</p><pre><code></code></pre><p>1777 -1</p><hr><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<queue>#include<algorithm>#include<vector>using namespace std;vector<int>gra[10005];queue<int>q;int mon[10005];int ver,edge;int ans;int least;void topsort(){    int cnt=0;    for(int i=1;i<=ver;++i)    {        if(gra[i][0]==0)          {               q.push(i);          }    }    while(!q.empty())    {        int u=q.front();        cnt++;        ans+=mon[u];        q.pop();        for(int i=1;i<gra[u].size();++i)        {            if(--gra[gra[u][i]][0]==0)            {                q.push(gra[u][i]);                mon[gra[u][i]]=mon[u]+1;            }        }    }    if(cnt!=ver)    {printf("-1\n");    return;}    else    {        printf("%d\n",ans);        return;    }}int main(void){    while(~scanf("%d%d",&ver,&edge))    {        ans=0;        for(int i=1;i<=ver;++i)        {            gra[i].clear();            mon[i]=888;            gra[i].push_back(0);        }        for(int i=1;i<=edge;++i)        {            int u,v;            scanf("%d%d",&u,&v);            gra[v].push_back(u);            gra[u][0]++;        }        topsort();    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于dp做法的一点...理解QAQ很浅显的 hdu1723Distribute Message（第一个独立做出来的dp题...大水题） 三种做法 暴力递归+记忆化搜索+dp</title>
      <link href="2018/08/06/guan-yu-dp-zuo-fa-de-yi-dian-li-jie-qaqhexo-new-hdu1025-hen-qian-xian-de-hdu1723distribute-message-di-yi-ge-du-li-zuo-chu-lai-de-dp-ti-da-shui-ti-san-chong-zuo-fa-bao-li-di-gui-ji-yi-hua-sou-suo-dp/"/>
      <url>2018/08/06/guan-yu-dp-zuo-fa-de-yi-dian-li-jie-qaqhexo-new-hdu1025-hen-qian-xian-de-hdu1723distribute-message-di-yi-ge-du-li-zuo-chu-lai-de-dp-ti-da-shui-ti-san-chong-zuo-fa-bao-li-di-gui-ji-yi-hua-sou-suo-dp/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Distribute-Message"><a href="#Distribute-Message" class="headerlink" title="Distribute Message"></a><strong>Distribute Message</strong></h1><p><strong><em>*</em>*Time Limit: 1000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 2276  Accepted Submission(s): 1144*\</strong>***</p><p>Problem Description</p><p>The contest’s message distribution is a big thing in prepare. Assuming N students stand in a row, from the row-head start transmit message, each person can transmit message to behind M personals, and how many ways could row-tail get the message?</p><p>Input</p><p>Input may contain multiple test cases. Each case contains N and M in one line. (0&lt;=M&lt;N&lt;=30)<br>When N=0 and M=0, terminates the input and this test case is not to be processed.</p><p>Output</p><p>Output the ways of the Nth student get message.</p><p>Sample Input</p><pre><code></code></pre><p>4 1</p><p>4 2</p><p>0 0</p><p>Sample Output</p><pre><code></code></pre><p>1</p><p>3</p><pre><code></code></pre><p><em>Hint</em></p><p>4 1 : A-&gt;B-&gt;C-&gt;D 4 2 : A-&gt;B-&gt;C-&gt;D, A-&gt;C-&gt;D, A-&gt;B-&gt;D</p><hr><p>可以说是很水的一道题目了 但是看了一个关于dp的视频之后终于对dp有点理解了 之前对dp一头雾水不知道从哪里下手</p><p>一直搜题解报告动态转移方程才能敲出来这样子</p><p>直到看了三个题解之后我看了一个视频 （我查了查是七月在线的动态规划实战课，也不是很贵）</p><p>dp定义啊之类的网上很多 就不再copy了 我就说说dp的做法吧（也是刚看的视频教程里面说的）</p><p>1.先找到最暴力的解法，然后去除冗余（这里我就用最暴力的方法写了一个递归，从上到下的（n到1），感觉从下到上（1到n）很难找到那个关系）</p><p>2.设计并存储状态（一维，二维，三维数组，map，其实这里我刚做这个题的时候并没有想到要几维，写完了记忆化搜索动态转移方程基本就出来了）</p><p>3.递归式（转移方程）</p><p>4.自底向上计算最优解（编程方式）</p><p>如果没思路的话，就先写一遍暴力吧！</p><p>附代码</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>using namespace std;int rf(int m,int n){    int sum=0;    if(n==1)        return 1;    for(int i=1;i<=m;++i)    {        if(n-i>=1)            sum+=rf(m,n-i);    }    return sum;}int main(void){    int n,m;    while(scanf("%d%d",&n,&m)!=EOF&&n+m!=0)    {       int h= rf(m,n);       printf("%d\n",h);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> hdu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1025</title>
      <link href="2018/08/06/hdu1025/"/>
      <url>2018/08/06/hdu1025/</url>
      
        <content type="html"><![CDATA[<h1 id="Humble-Numbers"><a href="#Humble-Numbers" class="headerlink" title="Humble Numbers"></a><strong>Humble Numbers</strong></h1><p><strong><em>*</em>*Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 29610  Accepted Submission(s): 12977*\</strong>***</p><p>Problem Description</p><p>A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, … shows the first 20 humble numbers.</p><p>Write a program to find and print the nth element in this sequence</p><p>Input</p><p>The input consists of one or more test cases. Each test case consists of one integer n with 1 &lt;= n &lt;= 5842. Input is terminated by a value of zero (0) for n.</p><p>Output</p><p>For each test case, print one line saying “The nth humble number is number.”. Depending on the value of n, the correct suffix “st”, “nd”, “rd”, or “th” for the ordinal number nth has to be used like it is shown in the sample output.</p><p>Sample Input</p><pre class=" language-html"><code class="language-html"></code></pre><p>1 2 3 4 11 12 13 21 22 23 100 1000 5842 0</p><p>Sample Output</p><pre class=" language-html"><code class="language-html"></code></pre><p>The 1st humble number is 1. The 2nd humble number is 2. The 3rd humble number is 3. The 4th humble number is 4. The 11th humble number is 12. The 12th humble number is 14. The 13th humble number is 15. The 21st humble number is 28. The 22nd humble number is 30. The 23rd humble number is 32. The 100th humble number is 450. The 1000th humble number is 385875. The 5842nd humble number is 2000000000.</p><p>题目大题意思就是求出丑数序列 丑数就是因数只有2,3,5，7的数</p><p>一开始就想暴力求一遍 然后用数组存起来排个序 想了好久也没想出dp方程是啥</p><p>搜了题解之后发现还是挺简单的…</p><p>就是说丑数肯定是2,3,5,7不断相乘得到的，一开始是2,2<em>2，3,5,7是3,2</em>2,5，3*2,7是4 每一次的丑数都是前面的数乘2,或3或5或7之后的最小数</p><p>所以dp[i]=min(dp[f2]*2,dp[f3]*3,dp[f5]*5,dp[f7]*7)</p><hr><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>using namespace std;typedef long long ll;ll  dp[6000]={0,1};int f2=1,f3=1,f5=1,f7=1;int main(void){    for(int i=2;i<=5842;++i)    {        dp[i]=min(min(dp[f2]*2,dp[f3]*3),min(dp[f5]*5,dp[f7]*7));        if(dp[i]==dp[f2]*2)f2++;        if(dp[i]==dp[f3]*3)f3++;        if(dp[i]==dp[f5]*5)f5++;        if(dp[i]==dp[f7]*7)f7++;    }    int n;    while(scanf("%d",&n)!=EOF&&n)    {        if(n%10==1&&n%100!=11)            printf("The %dst humble number is %d.\n",n,dp[n]);        else if(n%10==2&&n%100!=12)            printf("The %dnd humble number is %d.\n",n,dp[n]);        else if(n%10==3&&n%100!=13)            printf("The %drd humble number is %d.\n",n,dp[n]);        else{            printf("The %dth humble number is %d.\n",n,dp[n]);        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> hdu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上色的纱雾（二分搜索）</title>
      <link href="2018/08/04/shang-se-de-sha-wu-er-fen-sou-suo/"/>
      <url>2018/08/04/shang-se-de-sha-wu-er-fen-sou-suo/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1556 Color the ball 线段树（区间修改单点查询）</title>
      <link href="2018/08/04/hdu1556-color-the-ball-xian-duan-shu-qu-jian-xiu-gai-dan-dian-cha-xun/"/>
      <url>2018/08/04/hdu1556-color-the-ball-xian-duan-shu-qu-jian-xiu-gai-dan-dian-cha-xun/</url>
      
        <content type="html"><![CDATA[<hr><p>题意大体就是给你一个区间</p><p>然后每次给你一个区间 这个区间内的点加1</p><p>问最后每个点的大小是多少</p><p>这个地方运用懒节点，区间修改时积累下来 当查询是再对区间修改有影响的点进行修改。</p><h3 id="Color-the-ball"><a href="#Color-the-ball" class="headerlink" title="Color the ball"></a>Color the ball</h3><p>Time Limit: 3000 ms / Memory Limit: 32768 kb</p><p>Description</p><p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p><p>Input</p><p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p><p>Output</p><p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p><pre><code>31 12 23 331 11 21 301 1 13 2 1</code></pre><hr><pre class=" language-c++"><code class="language-c++">#include<cstdio>using namespace std;#define fm (t[k].l+t[k].r)>>1const int maxn=100000+5;int x,y,a,b;int ans=0;struct node{    int l,r,w,f;};node t[maxn*4+5];void build(int k,int l,int r){    t[k].l=l;    t[k].r=r;    if(t[k].l==t[k].r)    {        t[k].w=0;        t[k].f=0;        return;    }    int m=(t[k].r+t[k].l)>>1;    build(2*k,l,m);    build(2*k+1,m+1,r);    t[k].w=0;    t[k].f=0;}void down(int k){    t[k*2].f+=t[k].f;    t[k*2+1].f+=t[k].f;    t[k*2].w+=t[k].f*(t[k*2].r-t[k*2].l+1);    t[k*2+1].w+=t[k].f*(t[k*2+1].r-t[k*2+1].l+1);    t[k].f=0;}void add(int k){    if(t[k].l>=a&&t[k].r<=b)    {        t[k].w+=(t[k].r-t[k].l+1);        t[k].f+=1;//区间修改时积累f        return;    }   // if(t[k].f) down(k);//在区间修改时不下传    int m=fm;    if(a<=m) add(2*k);    if(b>m) add(2*k+1);    t[k].w+=t[k*2].w+t[k*2+1].w;}void ask_point(int k){    if(t[k].l==t[k].r)    {        ans=t[k].w;        return;    }    if(t[k].f) down(k);//查询时把点所属于的区间的懒节点积累值下传    int m=fm;    if(x<=m) ask_point(2*k);    else ask_point(2*k+1);}int main(void){    int n;    while(scanf("%d",&n)!=EOF&&n!=0)    {        build(1,1,n);        for(int i=0;i<n;++i)        {            scanf("%d%d",&a,&b);            add(1);        }        for(int i=1;i<=n;++i)        {            x=i;            ask_point(1);            if(i==1)            printf("%d",ans);            else                printf(" %d",ans);        }        printf("\n");    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于kmp的一点个人理解 poj3461 Oulipo (kmp模板题)</title>
      <link href="2018/08/04/guan-yu-kmp-de-yi-dian-ge-ren-li-jie-poj3461-oulipo-kmp-mo-ban-ti/"/>
      <url>2018/08/04/guan-yu-kmp-de-yi-dian-ge-ren-li-jie-poj3461-oulipo-kmp-mo-ban-ti/</url>
      
        <content type="html"><![CDATA[<hr><p>这个题就是先给子串，然后给母串，问子串在母串中出现的次数。</p><h3 id="Oulipo"><a href="#Oulipo" class="headerlink" title="Oulipo"></a>Oulipo</h3><p>Time Limit: 1000 ms / Memory Limit: 32768 kb</p><p>Description</p><p>The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book:</p><p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p><p>Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces.</p><p>So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap.</p><p>Input</p><p>The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:</p><p>One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W).<br>One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000.</p><p>Output</p><p>For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.</p><hr><pre><code>3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN</code></pre><pre><code>130</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<cstring>using namespace std;const int maxn=10000005;int knext[maxn];char s[maxn],t[maxn];int slen,tlen;void getnext(){    int j,k;    j=0;k=-1;knext[0]=-1;    while(j<tlen)    {        if(k==-1||t[j]==t[k])        {            knext[++j]=++k;        }        else            k=knext[k];    }}int count_kmp(){    int i=0,k=0;    int ans=0;    int j=0;    if(slen==1&&tlen==1)    {        if(s[0]==t[0])            return 1;        else            return 0;    }    getnext();    for(i=0;i<slen;++i)    {        while(j>0&&s[i]!=t[j])            j=knext[j];        if(s[i]==t[j])            j++;        if(j==tlen)        {            ans++;            j=knext[j];        }    }    return ans;}int main(void){    int a;  scanf("%d",&a);    while(a--)    {        scanf("%s",t);        scanf("%s",s);        slen=strlen(s);        tlen=strlen(t);        printf("%d\n",count_kmp());    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> poj </tag>
            
            <tag> kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1166 敌兵布阵 线段树</title>
      <link href="2018/07/20/hdu1166-di-bing-bu-zhen-xian-duan-shu/"/>
      <url>2018/07/20/hdu1166-di-bing-bu-zhen-xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<p>Problem Description</p><p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p><p>Input</p><p>第一行一个整数T，表示有T组数据。<br>每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有40000条命令</p><p>Output</p><p>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p><p>Sample Input</p><p>1</p><p>10</p><p>1 2 3 4 5 6 7 8 9 10</p><p>Query 1 3</p><p>Add 3 6</p><p>Query 2 7</p><p>Sub 10 2</p><p>Add 6 3</p><p>Query 3 10</p><p>End</p><p>区间查询和单点修改 先po代码 以后补充</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,h);</span><br><span class="line">        h++;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</span><br><span class="line">            {</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"Query"</span>)</span><br><span class="line">        {</span><br><span class="line"> </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);<span class="comment">//cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">            ask(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"Add"</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            </span><br><span class="line">            add(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"Sub"</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            y=-y;</span><br><span class="line">            add(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"End"</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主席树模板</title>
      <link href="2018/07/19/zhu-xi-shu-mo-ban/"/>
      <url>2018/07/19/zhu-xi-shu-mo-ban/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/acmore_xiong/article/details/52870338">https://blog.csdn.net/acmore_xiong/article/details/52870338</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1275 两车追击相遇问题</title>
      <link href="2018/07/17/hdu1275-liang-che-zhui-ji-xiang-yu-wen-ti/"/>
      <url>2018/07/17/hdu1275-liang-che-zhui-ji-xiang-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="两车追及或相遇问题"><a href="#两车追及或相遇问题" class="headerlink" title="两车追及或相遇问题"></a>两车追及或相遇问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 1764  Accepted Submission(s): 546**</strong></p><p>Problem Description</p><p>外号叫“猪头三”的小学生在数学课上，经常遇到两车相遇或追及的方程题，经过长时间的练习，他发现了许多规律，然而他不懂计算机，他想请你帮忙编写一个计算机程序，解决他的问题。<br>题目的描述是这样的：甲、乙两地相距L公里，A车的速度为VA公里/小时，B车的速度为VB公里/小时，A车和B车开始时分别在甲、乙两地，现在两车同时从甲、乙两地出发，并且开始计时，两车到达甲、乙两地后返回继续行驶，这样会有许多次追及或相遇的时候，我们假定称追及或相遇的时候为“重合”，请输出“重合”时的时间以及离甲、乙两地较近地的距离。</p><p>Input</p><p>本题有多个测试数据组，第一行为测试数据组数N，接着是N行数据，每行的数据按顺序分别为实数类型的距离、A车的速度、B车的速度以及整数类型的第几次“重合”的序号数(&lt;=1000)。</p><p>Output</p><p>Time=xxxx.xxx Dist=xx.xxx输出的精度为精确到小数点后三位。</p><p>Sample Input</p><p>2 120.7 90.0 90.0 10 100.5 80.7 69.3 1</p><p>Sample Output</p><p>Time=12.741 Dist=60.350 Time=0.670 Dist=46.431</p><hr><p>一开始想的每段每段的判断，但是发现过于麻烦，然后发现大佬的简单解答。</p><p>这个题的关键就是，每两次相遇之间间隔了2L（无论两者速度多少 第一次相遇肯定是L 然后每次相遇都一共走了2L可以自己想几个模式判断一下）</p><p>并且每两次追及之间速度大的车经过的路程减去速度小的车所经过的路程也是2L(第一次也是L然后每次追及之间都间隔了2L)</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<string>#include<algorithm>#include<string.h>#include<math.h>using namespace std;double va,vb,k,l;//这里应该把k设为intdouble ans[10000];int main(void){    int t;    cin>>t;    while(t--)    {        cin>>l>>va>>vb>>k;        int i=0;        memset(ans,0,sizeof(ans));        for(int j=1;j<1000;++j)//注意j从1开始        {            ans[i++]=(2.0*j-1.0)*l/(va+vb);//计算相遇            if(va!=vb)            ans[i++]=(2.0*j-1.0)*l/fabs(va-vb);//计算追及        }        sort(ans,ans+i);//时间可能不一定是顺序，所以先排序        double d=0;        --k;        d=(ans[(int)k])*va;        while(d>l)d-=l;//找到距离        d=d<l-d?d:l-d;        printf("Time=%.3f Dist=%.3f\n",ans[(int)k],d);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1274 展开字符串 递归</title>
      <link href="2018/07/16/hdu1274-zhan-kai-zi-fu-chuan-di-gui/"/>
      <url>2018/07/16/hdu1274-zhan-kai-zi-fu-chuan-di-gui/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="展开字符串"><a href="#展开字符串" class="headerlink" title="展开字符串"></a>展开字符串</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 3133  Accepted Submission(s): 1511**</strong></p><p>Problem Description</p><p>在纺织CAD系统开发过程中，经常会遇到纱线排列的问题。<br>该问题的描述是这样的：常用纱线的品种一般不会超过25种，所以分别可以用小写字母表示不同的纱线，例如：abc表示三根纱线的排列；重复可以用数字和括号表示，例如：2(abc)表示abcabc；1(a)=1a表示a;2ab表示aab;如果括号前面没有表示重复的数字出现，则就可认为是1被省略了，如：cd(abc)=cd1(abc)=cdabc;这种表示方法非常简单紧凑，也易于理解；但是计算机却不能理解。为了使计算机接受，就必须将简单紧凑的表达方式展开。某ACM队接受了此项任务。现在你就是该ACM队的一员，请你把这个程序编写完成。<br>已知条件：输入的简单紧凑表达方式的长度不超过250个字符；括号前表示重复的数不超过1000；不会出现除了数字、括号、小写字母以外的任何其他字符；不会出现括号不配对等错误的情况（错误处理已由ACM其他队员完成了）。</p><p>Input</p><p>本题有多个测试数据组，第一行输入的就是数据组数N，接着就是N行表达式，表达式是按照前面介绍的意义书写的。</p><p>Output</p><p>输出时含有N行，每行对应一个输入的表达式。</p><p>Sample Input</p><p>2 1(1a2b1(ab)1c)</p><p>3(ab2(4ab)</p><p>这种括号运算的问题就是写一个函数可以处理所有情况下的字符</p><p>Sample Output</p><p>abbabc</p><p>abaaaabaaaababaaaabaaaababaaaabaaaab</p><hr><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>#include<cstdio>#include<algorithm>using namespace std;string s;int dfs(int j)//dfs返回的是字符串的长度-2，记录下来方便下一步的运算{    int num=0;//记录数字的大小   // printf(":");    for(int i=j;i<s.size();++i) 从j开始输出="" &#123;="" if(s[i]="">='a'&amp;&amp;s[i]&lt;='z')//如果是字母则输出        {            int tem=max(num,1);//num最小是1，这个是为了避免前面是1省略的情况            for(int h=0;h<tem;++h) &#123;="" printf("%c",s[i]);="" &#125;="" num="0;//不要忘记将num重新归零" else="" if(s[i]="">='0'&amp;&amp;s[i]&lt;='9')//如果是数字的话那么就进行累计，相当于字符串处理        {            num=num*10+s[i]-'0';            //cout&lt;&lt;"*";        }        else if(s[i]=='(')//如果是左括号相当于重新开始        {            int tmp=max(num,1);            int m=0;            for(int h=0;h<tmp;++h) &#123;="" m="dfs(i+1);" &#125;="" i="i+m+1;//直接跳到右括号之后" num="0;" else="" return="" i-j;="" 返回字符串长度-2="" int="" main(void)="" t;="" cin="">&gt;t;    while(t--)    {        cin&gt;&gt;s;        dfs(0);//直接从第0位开始        printf("\n");    }}</tmp;++h)></tem;++h)></s.size();++i)></algorithm></cstdio></string></iostream></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>divide by three, multiply by two</title>
      <link href="2018/07/09/divide-by-three-multiply-by-two/"/>
      <url>2018/07/09/divide-by-three-multiply-by-two/</url>
      
        <content type="html"><![CDATA[<hr><p>D. Divide by three, multiply by two</p><p>time limit per test</p><p>1 second</p><p>memory limit per test</p><p>256 megabytes</p><p>input</p><p>standard input</p><p>output</p><p>standard output</p><p>Polycarp likes to play with numbers. He takes some integer number xx, writes it down on the board, and then performs with it n−1n−1 operations of the two kinds:</p><ul><li>divide the number xx by 33 (xx must be divisible by 33);</li><li>multiply the number xx by 22.</li></ul><p>After each operation, Polycarp writes down the result on the board and replaces xx by the result. So there will be nn numbers on the board after all.</p><p>You are given a sequence of length nn — the numbers that Polycarp wrote down. This sequence is given in arbitrary order, i.e. the order of the sequence can mismatch the order of the numbers written on the board.</p><p>Your problem is to rearrange (reorder) elements of this sequence in such a way that it can match possible Polycarp’s game in the order of the numbers written on the board. I.e. each next number will be exactly two times of the previous number or exactly one third of previous number.</p><p>It is guaranteed that the answer exists.</p><p>Input</p><p>The first line of the input contatins an integer number nn (2≤n≤1002≤n≤100) — the number of the elements in the sequence. The second line of the input contains nn integer numbers a1,a2,…,ana1,a2,…,an (1≤ai≤3⋅10181≤ai≤3⋅1018) — rearranged (reordered) sequence that Polycarp can wrote down on the board.</p><p>Output</p><p>Print nn integer numbers — rearranged (reordered) input sequence that can be the sequence that Polycarp could write down on the board.</p><p>It is guaranteed that the answer exists.</p><hr><p>这道题其实就是 按能膜3的数目由高到低排列 因为只有两种方式 一种是除以3一种是乘以2 所以能膜的3的数目肯定是依次递减的</p><p>并且 如果相邻的两者膜3的数目相等 那肯定是数小的在前面 数大的在后面 选择的是乘以2的方式</p><p>所以pair先比较除以3的数目 再比较乘以2的数目。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<algorithm>using namespace std;typedef long long ll;ll n,x;pair<ll,ll>a[105];int main(void){    ll i,c,t;    cin>>n;    for(i=0;i<n;++i)    {        cin>>x;        for(t=x,c=0;t%3==0;t/=3)c++;        a[i]={-c,x};    }    sort(a,a+n);    for(int i=0;i<n;++i)    {        cout<<a[i].first<<'*';        cout<<a[i].second<<' ';    }    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1496</title>
      <link href="2018/05/14/hdu1496/"/>
      <url>2018/05/14/hdu1496/</url>
      
        <content type="html"><![CDATA[<p>这个题挺水的，但是一开始想的比较复杂。</p><p>一开始就准备暴力剪枝，分为两种情况1,3（三个同号一个异号）和2,2（两个分别同号）</p><p>但是写了写再加上别的小地方的剪枝比较复杂。</p><p>果断放弃了。</p><p>然后搜了之后还是只能感叹 磨刀不误砍柴工。</p><p>水题是要动脑子的呀！</p><p>这个题的思路就是由判断abcd相加等于零变为判断ab与cd的和的相反数相等。</p><p>这样复杂度很神奇的减少到了一个很少的步（由n（4）变为2n(2)）</p><p>贴上代码</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<string.h>#include<algorithm>#include<cmath>using namespace std;int hash1[2000011];int main(void){    int a, b, c, d;    while (scanf("%d%d%d%d", &a, &b, &c, &d) != EOF)    {        int sum = 0;        if (a*b > 0 && b*c > 0 && c*d > 0)//简单剪枝，判断abcd是否都是同号        {            printf("0\n");            continue;        }        memset(hash1, 0, sizeof(hash1));//每一步不能忘记初始化哈希表        for (int i = 1;i <= 100;++i)//先计算ab的和，1000000是防止ab的和是负数        {            for (int j = 1;j <= 100;++j)            {                hash1[a*i*i + b*j*j + 1000000]++;            }        }        for (int i = 1;i <= 100;++i)//计算cd和的相反数，并判断此时改数是否在哈希表中        {            for (int j = 1;j <= 100;++j)            {                sum += hash1[-c*i*i - d*j*j + 1000000];            }        }        printf("%d\n", sum * 16);//因为x1,x2,x3,x4都有可能是正数或者负数所以有2的4次方种可能性。    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水题hdu1213-1</title>
      <link href="2018/04/06/shui-ti-hdu1213-1/"/>
      <url>2018/04/06/shui-ti-hdu1213-1/</url>
      
        <content type="html"><![CDATA[<p>很简单的并查集</p><p>找父节点个数就是需要的桌子数</p><p>调试了好久是因为把find的while写成了if所以每次只查找一次父节点。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>&nbsp;#include<string.h>using namespace std;int n1, m;struct node {    int fa;};node s[1001];int sum[1001];void sets(){    for (int i = 0;i < n1;++i)    {        s[i].fa = i;    }}int find(int r){    int n=r;    while (n != s[n].fa)    {        n = s[n].fa;    }    int i = r, j;    while (i !=n )    {        j = s[i].fa;        s[i].fa = n;        i = j;    }    return n;}void join(int p1, int p2){    int x = find(p1);    int y = find(p2);    //printf("%d %d\n", x, y);    if (x != y)    {        s[x].fa = y;    }}int main(void){    int n;    scanf("%d", &n);    while (n-- > 0)    {        memset(sum, 0, sizeof(sum));        scanf("%d%d", &n1, &m);        sets();        while (m-- > 0)        {            int p1, p2;            scanf("%d%d", &p1, &p2);            join(p1-1, p2-1);        }        for (int i = 0;i < n1;++i)        {            int x = find(i);            //printf("%d\n", x);            sum[x] = 1;        }        int sum1=0;        for (int i = 0;i < n1;++i)        {            sum1 += sum[i];        }        cout << sum1 << endl;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于深搜具体的过程一点理解</title>
      <link href="2018/03/02/guan-yu-shen-sou-ju-ti-de-guo-cheng-yi-dian-li-jie/"/>
      <url>2018/03/02/guan-yu-shen-sou-ju-ti-de-guo-cheng-yi-dian-li-jie/</url>
      
        <content type="html"><![CDATA[<p>这几天看深搜一直纠结</p><p>函数里面for循环递归，那分出去的分支是先进行一个还是同时进行，彼此之间有没有影响？</p><p>答案应该是先进行一个 而且有影响。</p><p>以此题为例（poj3278）</p><hr><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Time Limit: 1000 ms / Memory Limit: 32768 kb</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above. </p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set) </p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). </p><hr><pre class=" language-c++"><code class="language-c++">#include <cstdio>#include <iostream>#include <string>using namespace std;int black=0;int n, k;char str[25][25];int dir[4][2] = { 1,0,0,-1,0,1,-1,0 };int step=0;void bfs(int x,int y){    int i, j;    int xx, yy;    for (i = 0;i < k;++i)    {        for (j = 0;j < n;++j)        {            printf("%c", str[i][j]);        }        printf("\n");    }    for (i = 0;i < 4;++i)    {        xx = x + dir[i][0];        yy = y + dir[i][1];        if (xx >= 0 && yy >= 0 && xx < k&&yy < n &&str[xx][yy] == '.')        {            str[xx][yy] = '#';            black++;            step += 3 - i;            bfs(xx, yy);        }        else            printf("false%d\n",step);    }}int main(void){    while (scanf("%d%d", &n, &k) != EOF)    {        if (n == 0 && k == 0)            break;        memset(str, 0, sizeof(str));        int i, j;        int dx, dy;        for (i = 0;i < k;++i)        {            getchar();            for (j = 0;j < n;++j)            {                scanf("%c", &str[i][j]);            }        }        for (i = 0;i < k;++i)        {            for (j = 0;j < n;++j)            {                if (str[i][j] == '@')                {                    dx = i;                    dy = j;                }            }        }        str[dx][dy] = '#';        black++;        bfs(dx, dy);        cout << black << endl;        black = 0;    }}</code></pre><p>以下面为例，可见先是找到一个可行的点一直继续下去，如果走不动就输出false,（以下、左、右、上的顺序进行）直到最后输出了15个false，因为最后一个点是4个false，所以是先一条路走下去，然后反过头来继续前面的循环，因为数组已经变化了，所以都是false，输出了11个，这里可用定义的变量step证明。</p><p>3 3<br>@..<br>…<br>…<br>#..<br>…<br>…<br>#..<br>#..<br>…<br>#..<br>#..<br>#..<br>false6<br>false6<br>#..<br>#..<br>##.<br>false7<br>false7<br>#..<br>#..<br>###<br>false8<br>false8<br>false8<br>#..<br>#.#<br>###<br>false8<br>#..<br>###<br>###<br>false10<br>false10<br>false10<br>##.<br>###<br>###<br>false10<br>false10<br>###<br>###<br>###<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11<br>false11</p><p>9</p><p>而如何遍历所有的可能走法呢？</p><p>bfs(xx,yy)后把str[xx][yy]=’.’就可以了。</p><p>Ep:</p><p>2 2</p><p>@.<br>..<br>#.<br>..<br>#.<br>#.<br>false3<br>false3<br>#.<br>##<br>false4<br>false4<br>false4<br>##<br>##<br>false4<br>false4<br>false4<br>false4<br>false4<br>false4<br>##<br>..<br>##<br>.#<br>false8<br>##<br>##<br>false10<br>false10<br>false10<br>false10<br>false10<br>false10<br>false10<br>false10<br>false10<br>false10<br>7</p><p>Ps：现在回头看其实就是画颗树就可以解释的东西…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
