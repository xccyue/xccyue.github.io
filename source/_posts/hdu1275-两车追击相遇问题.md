---
title: hdu1275 两车追击相遇问题
date: 2018-07-17 08:17:10
author: Chaoyue Xing
img: 
top: false
cover: false
coverImg: 
password: 
toc: false
mathjax: false
summary:
categories: Algorithm
tags: 
  - 思维
  - hdu
---

---

# 两车追及或相遇问题

***\*Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 1764  Accepted Submission(s): 546\****

Problem Description

外号叫“猪头三”的小学生在数学课上，经常遇到两车相遇或追及的方程题，经过长时间的练习，他发现了许多规律，然而他不懂计算机，他想请你帮忙编写一个计算机程序，解决他的问题。
题目的描述是这样的：甲、乙两地相距L公里，A车的速度为VA公里/小时，B车的速度为VB公里/小时，A车和B车开始时分别在甲、乙两地，现在两车同时从甲、乙两地出发，并且开始计时，两车到达甲、乙两地后返回继续行驶，这样会有许多次追及或相遇的时候，我们假定称追及或相遇的时候为“重合”，请输出“重合”时的时间以及离甲、乙两地较近地的距离。

Input

本题有多个测试数据组，第一行为测试数据组数N，接着是N行数据，每行的数据按顺序分别为实数类型的距离、A车的速度、B车的速度以及整数类型的第几次“重合”的序号数(<=1000)。

Output

Time=xxxx.xxx Dist=xx.xxx输出的精度为精确到小数点后三位。

Sample Input

2 120.7 90.0 90.0 10 100.5 80.7 69.3 1

Sample Output

Time=12.741 Dist=60.350 Time=0.670 Dist=46.431

---

一开始想的每段每段的判断，但是发现过于麻烦，然后发现大佬的简单解答。

这个题的关键就是，每两次相遇之间间隔了2L（无论两者速度多少 第一次相遇肯定是L 然后每次相遇都一共走了2L可以自己想几个模式判断一下）

并且每两次追及之间速度大的车经过的路程减去速度小的车所经过的路程也是2L(第一次也是L然后每次追及之间都间隔了2L)

```c++
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;
double va,vb,k,l;//这里应该把k设为int
double ans[10000];
int main(void)
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>l>>va>>vb>>k;
        
        int i=0;
        memset(ans,0,sizeof(ans));
        for(int j=1;j<1000;++j)//注意j从1开始
        {
            ans[i++]=(2.0*j-1.0)*l/(va+vb);//计算相遇
            if(va!=vb)
            ans[i++]=(2.0*j-1.0)*l/fabs(va-vb);//计算追及
        }
        sort(ans,ans+i);//时间可能不一定是顺序，所以先排序
        double d=0;
        --k;
        d=(ans[(int)k])*va;
        while(d>l)d-=l;//找到距离
        d=d<l-d?d:l-d;
        printf("Time=%.3f Dist=%.3f\n",ans[(int)k],d);
 
 
 
    }
}
```

