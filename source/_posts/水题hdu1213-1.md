---
title: 水题hdu1213-1
date:  2018-04-06 09:58:22
author: Chaoyue Xing
img: 
top: false
cover: false
coverImg: 
password: 
toc: false
mathjax: false
summary:
categories: Algorithm
tags: 
  - 并查集
  - hdu
---

很简单的并查集

找父节点个数就是需要的桌子数

调试了好久是因为把find的while写成了if所以每次只查找一次父节点。

```c++
#include<iostream>
#include<cstdio>
 #include<string.h>
using namespace std;
int n1, m;
struct node {
	int fa;
};
node s[1001];
int sum[1001];
void sets()
{
	for (int i = 0;i < n1;++i)
	{
		s[i].fa = i;
	}
}
int find(int r)
{
	int n=r;
	while (n != s[n].fa)
	{
		n = s[n].fa;
	}
	int i = r, j;
	while (i !=n )
	{
		j = s[i].fa;
		s[i].fa = n;
		i = j;
	}
	return n;
}
void join(int p1, int p2)
{
	int x = find(p1);
	int y = find(p2);
	//printf("%d %d\n", x, y);
	if (x != y)
	{
		s[x].fa = y;
	}
}
 
 
int main(void)
{
	int n;
	scanf("%d", &n);
	while (n-- > 0)
	{
		
		memset(sum, 0, sizeof(sum));
		scanf("%d%d", &n1, &m);
		sets();
		while (m-- > 0)
		{
			int p1, p2;
			scanf("%d%d", &p1, &p2);
			join(p1-1, p2-1);
		}
		for (int i = 0;i < n1;++i)
		{
			int x = find(i);
			//printf("%d\n", x);
			sum[x] = 1;
		}
		int sum1=0;
		for (int i = 0;i < n1;++i)
		{
			sum1 += sum[i];
		}
		cout << sum1 << endl;
	}
}
```

